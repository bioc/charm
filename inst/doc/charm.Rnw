%\VignetteIndexEntry{charm Vignette}
%\VignetteDepends{charmData, BSgenome.Hsapiens.UCSC.hg18}
%\VignetteKeywords{}
%\VignettePackage{charm}
\documentclass{article}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{pdfpages}

\begin{document}
\title{Using the charm package to estimate DNA methylation levels and find differentially methylated regions}
\date{November, 2011}
\author{Martin Aryee\footnote{aryee@jhu}, Peter Murakami, Rafael Irizarry}
\maketitle
\begin{center}
Johns Hopkins School of Medicine / Johns Hopkins School of Public Health\\Baltimore, MD, USA
\end{center}

<<setup, echo=FALSE, results=hide>>=
options(width=60)
options(continue=" ")
options(prompt="R> ")
@ 

\section{Introduction}

The Bioconductor package \Rpackage{charm} can be used to analyze DNA methylation data generated using McrBC fractionation and two-color Nimblegen microarrays. It is customized for use with data the from the custom CHARM microarray \cite{IrizarryGenomeRes2008}, but can also be applied to many other Nimblegen designs. The preprocessing and normalization methods are described in detail in \cite{AryeeBiostatistics2011}.

Functions include:
\begin{itemize}
\item Quality control
\item Finding suitable control probes for normalization
\item Percentage methylation estimates
\item Identification of differentially methylated regions
\item Plotting of differentially methylated regions
\end{itemize}

As input we will need raw Nimblegen data (.xys) files and a corresponding annotation package built with pdInfoBuilder. This vignette uses the following packages:
\begin{itemize}
\item \Rpackage{charm}: contains the analysis functions
\item \Rpackage{charmData}: an example dataset
\item \Rpackage{pd.charm.hg18.example}: the annotation package for the example dataset
\item \Rpackage{BSgenome.Hsapiens.UCSC.hg18}: A BSgenome object containing genomic sequence used for finding non-CpG control probes
\end{itemize}

Each sample is represented by two xys files corresponding to the untreated (green) and methyl-depleted (red) channels. The 532.xys and 635.xys suffixes indicate the green and red channels respectively.


\section{Analyzing data from the custom CHARM microarray}
Load the \Rpackage{charm} package:
<<loadCharm, results=hide>>=
library(charm)
library(charmData)
@

\section{Read in raw data}
Get the name of your data directory (in this case, the example data):
<<dataDir>>=
dataDir <- system.file("data", package="charmData")
dataDir
@

First we read in the sample description file:
<<phenodata>>=
phenodataDir <- system.file("extdata", package="charmData")
pd <- read.delim(file.path(phenodataDir, "phenodata.txt"))
phenodataDir
pd
@

A valid sample description file should contain at least the following (arbitrarily named) columns:
\begin{itemize}
\item a filename column
\item a sample ID column
\item a group label column (optional)
\end{itemize}

The sample ID column is used to pair the methyl-depleted and untreated data files for each sample. The group label column is used when identifying differentially methylated regions between experimental groups.

The \Rcode{validatePd} function can be used to validate the sample description file. When called with only a sample description data frame and no further options \Rcode{validatePd} will try to guess the contents of the columns.

<<validatePd>>=
res <- validatePd(pd)
@

Now we read in the raw data. The \Rcode{readCharm} command makes the assumption (unless told otherwise) that the two xys files for a sample have the same file name up to the suffixes 532.xys (untreated) and 635.xys (methyl-depleted).  The sampleNames argument is optional.

<<readData>>=
rawData <- readCharm(files=pd$filename, path=dataDir, sampleKey=pd, sampleNames=pd$sampleID)
rawData
@ 

\section{Array quality assessment}
We can calculate array quality scores and generate a pdf report with the \Rcode{qcReport} command.

A useful quick way of assessing data quality is to examine the untreated channel where we expect every probe to have signal. Very low signal intensities on all or part of an array can indicate problems with hybridization or scanning. The CHARM array and many other designs include background probes that do not match any genomic sequence. Any signal at these background probes can be assumed to be the result of optical noise or cross-hybridization. Since the untreated channel contains total DNA a successful hybridization would have strong signal for all untreated channel genomic probes. The array signal quality score (pmSignal) is calculated as the average percentile rank of the signal robes among these background probes. A score of 100 means all signal probes rank above all background probes (the ideal scenario).

<<qc>>=
qual <- qcReport(rawData, file="qcReport.pdf")
qual
@

The PDF quality report is shown in Appendix A. Three quality metrics are calculated for each array: 
\begin{enumerate}
\item Average signal strength: the average percentile rank of untreated channel signal probes among the background (anti-genomic) probes. 
\item Untreated channel signal standard deviation. The array is divided into a series of rectangular blocks and the average signal level calculated for each. Since probes are arranged randomly on the array there should be no large differences between blocks. Arrays with spatial artifacts have a larg standard deviation between blocks.
\item Methyl-depleted channel signal standard deviation.
\end{enumerate}

To remove samples with a quality score less than 78, we could do this:

<<Remove low-quality samples>>=
qc.min = 78
##Remove arrays with quality scores below qc.min:
rawData=rawData[,qual$pmSignal>=qc.min]
qual=qual[qual$pmSignal>=qc.min,]
pd=pd[pd$sampleID%in%rownames(qual),]
pData(rawData)$qual=qual$pmSignal
@

and to identify which probes have a mean quality score above 75 we could do this:

<<pmQuality>>=
pmq = pmQuality(rawData)
rmpmq = rowMeans(pmq)
okqc = which(rmpmq>75)
@

\section{Percentage methylation estimates and differentially methylated regions (DMRs)}

We now calculate probe-level percentage methylation estimates for each sample. As a first step we need to identify a suitable set of unmethylated control probes from CpG-free regions to be used in normalization.

<<getControlIndex>>=
library(BSgenome.Hsapiens.UCSC.hg18)
ctrlIdx <- getControlIndex(rawData, subject=Hsapiens, noCpGWindow=600)
@

We can check the success of the control probes by comparing their intensity distribution with the non-control probes (before any normalization in which the control probes are used).  

<<controlQC>>=
controlQC(rawData=rawData, controlIndex=ctrlIdx, IDcol="sampleID", expcol="tissue", ylimits=c(-6,8),
          outfile="boxplots_check.pdf", height=7, width=9)
@

The minimal code required to estimate methylation would be \Rcode{p <- methp(rawData, controlIndex=ctrlIdx)}. However, it is often useful to get \Rcode{methp} to produce a series of diagnostic density plots to help identify non-hybridization quality issues. The \Rcode{plotDensity} option specifies the name of the output pdf file, and 
the optional \Rcode{plotDensityGroups} can be used to give groups different colors.

<<methp_density>>=
grp <- pData(rawData)$tissue
p <- methp(rawData, controlIndex=ctrlIdx, 
	plotDensity="density.pdf", plotDensityGroups=grp) 
head(p)
@

For a simple unsupervised clustering of the samples, we can plot the results of a classical multi-dimensional scaling analysis.
<<cmdsplot>>=
cmdsplot(labcols=c("red","black","blue"), expcol="tissue", rawData=rawData, p=p, okqc=okqc, noXorY=TRUE, outfile="cmds_topN.pdf", topN=c(100000,1000))
@

The density plots are shown in Appendix B and the MDS plot is shown in Appendix C.

We can now identify differentially methylated regions using \Rcode{dmrFinder}:

<<dmrFinder, results=hide>>=
dmr <- dmrFinder(rawData, p=p, groups=grp, 
	compare=c("colon", "liver","colon", "spleen"),
        removeIf=expression(nprobes<4 | abs(diff)<.05 | abs(maxdiff)<.05))
@
<<headDmr>>=	
names(dmr)
names(dmr$tabs)
head(dmr$tabs[[1]])
@
When called without the \Rcode{compare} option, \Rcode{dmrFinder} performs all pairwise comparisons between the groups. 

We can also plot DMR candidates with the dmrPlot function.  Here we plot just the top DMR candidate from the first DMR table.
<<dmrPlot>>=
dmrPlot(dmr=dmr, which.table=1, which.plot=c(1), legend.size=1, all.lines=TRUE, all.points=FALSE, colors.l=c("blue","black","red"), colors.p=c("blue","black"), outpath=".")
@

We can also plot any given genomic regions using this data by using the regionPlot function, supplying the regions in a data frame that must have columns with names "chr", "start", and "end".  Naturally, regions that are not on the array will not appear in the resulting file.

<<regionPlot>>=
mytab = data.frame(chr=as.character(dmr$tabs[[1]]$chr[1]), start=as.numeric(c(dmr$tabs[[1]]$start[1])), end=as.numeric(c(dmr$tabs[[1]]$end[1])), stringsAsFactors=FALSE)
regionPlot(tab=mytab, dmr=dmr, outfile="myregions.pdf", which.plot=1:5, which.groups=c("liver","colon"), cl=c("blue","black"), legend.size=1, buffer=3000)
@

The DMR plot is shown in Appendix D, and the plot of the user-provided region is shown in Appendix E.


\section{Analysis of paired samples}
If the samples are paired, we can also analyze them as such.  To show this, let's pretend that the samples in our test data set are paired, and then use the dmrFinder function with the ``paired" argument set to TRUE and the ``pairs" argument specifying which samples are pairs.  (In this example we also have to lower the cutoff since there are not enough samples to find any regions with the default cutoff of 0.995.)
<<paired>>=
pData(rawData)$pair = c(1,1,2,2,1,2)
dmr2 <- dmrFinder(rawData, p=p, groups=grp, 
	compare=c("colon", "liver","colon", "spleen"),
        removeIf=expression(nprobes<4 | abs(diff)<.05 | abs(maxdiff)<.05),
        paired=TRUE, pairs=pData(rawData)$pair, cutoff=0.95)
@

We plot the, say, third DMR with the dmrPlot function (shown in Appendix F)
<<dmrPlot for paired analysis>>=
dmrPlot(dmr=dmr2, which.table=1, which.plot=c(3), legend.size=1, all.lines=TRUE, all.points=FALSE, colors.l=c("blue","black"), colors.p=c("blue","black"), outpath=".")
@


\bibliography{charmVignette}{}
\bibliographystyle{plain}

\section{Appendix A: Quality report}
\includepdf[pages=-]{qcReport.pdf}

\section{Appendix B: Density plots}
Each row corresponds to one stage of the normalization process (Raw data, After spatial and background correction, after within-sample normalization, after between-sample normalization, percentage methylation estimates). The left column shows all probes, while the right column shows control probes.
\includepdf{density.pdf}

\section{Appendix C: MDS plot}
\includepdf{cmds_topN.pdf}

\section{Appendix D: DMR plot}
DMR plot for the first DMR in the list. 
\includepdf{colon-liver.pdf}

\section{Appendix E: Plot of an arbitrary genomic region}
For the arbtirary region we just chose the first DMR.
\includepdf{myregions.pdf}

\section{Appendix F: DMR plot from analysis of paired samples}
DMR plot for the third DMR in the list
\includepdf{colon-liver_paired.pdf}
 
\section{Details}

This document was written using:

<<>>=
sessionInfo()
@ 


\end{document}
